[{"uri":"https://nymtech.net/docs/overview/","title":"Overview","tags":[],"description":"Nym is a blockchain-based privacy platform. It provides strong network-level privacy against sophisticated end-to-end attackers, and anonymous access control using blinded, re-randomizable, decentralized credentials.","content":"The internet has become essential to the functioning of modern society. Many aspects of daily life are now touched by the internet in ways that are both mundane and deeply revolutionary. Everything is accelerating.\nBut the internet we have is not the internet we wished we\u0026rsquo;d have. The increase in surveillance over the past twenty years has not been matched by advances in privacy tech. Nym is an attempt to redress this imbalance.\nThe Nym platform knits together several privacy technologies, integrating them into a system of cooperating networked nodes.\nAt a high level, our technologies include:\n a privacy enhancing signature scheme called Coconut. Coconut allows a shift in thinking about resource access control, from an identity-based paradigm based on who you are to a privacy-preserving paradigm based on right to use. Sphinx, a way of transmitting armoured, layer-encrypted information packets which are indistinguishable from each other at a binary level. a mixnet, which encrypts and mixes Sphinx packet traffic so that it cannot be determined who is communicating with whom. Our mixnet is based on a modified version of the Loopix design.  We\u0026rsquo;ll explore Coconut, Sphinx, and Loopix in detail in the next few sections. The most important thing to note is that these technologies ensure privacy at two different levels of the stack: network data transmission, and transactions.\nHow does Nym compare to other systems? Nym is the first system we\u0026rsquo;re aware of which provides integrated protection on both the network and transaction level at once. We think that this seamless approach gives the best possible privacy protections, ensuring that nothing falls through the cracks between systems.\nMost comparable systems concentrate on only one of these layers at a time.\nFor example, some blockchain-based systems contain zero knowledge proof systems that deal only with on-chain transaction privacy. This leaves network privacy as an exercise for the user. It\u0026rsquo;s easy to get it wrong.\nConversely, Tor deals only with network privacy, and has nothing built-in to help with transaction privacy. If you include identifiable information in your Tor network requests (which can happen accidentally), the privacy protections are void.\nSpeaking of Tor, our claim is that mixnets like Nym give stronger security guarantees against end-to-end network tracing attacks that are becoming easier to operationalize, and which we\u0026rsquo;ll see more of in future.\n"},{"uri":"https://nymtech.net/docs/overview/nym-platform/","title":"The Nym Platform","tags":[],"description":"An overview of the Nym platform architecture","content":"We are currently running a testnet with Nym validators and mixnodes. Together, the validators and mixnodes provide integrated access control and network privacy to users of the Nym platform. They are assisted by several other platform components: multiple types of clients, and gateway nodes.\nHere\u0026rsquo;s an overview of the entire network.\nThe Nym platform includes mixnodes, validators, gateways, and client code used for talking to the network. All of this is run in a decentralized, trustless fashion.\nThe mixnodes provide network security for network content and metadata, making it impossible to see who is communicating with who.\nValidators secure the network with proof-of-stake Sybil defences, determine which nodes are included within the network, and work together to create Coconut threshold credentials which provide anonymous access to data and resources.\nGateway nodes act as message storage for clients which may go offline and come back online again, and defend against denial of service attacks.\nBut the Nym platform (blue) is just infrastructure. The interesting part are the privacy enhanced apps (yellow) which can be created by privacy developers or hooked into the network for existing applications. We\u0026rsquo;ve included some (fictional) examples of things we think people might build or integrate. Read our docs and use your imagination, and you may come up with many more!\nNym-enhanced applications can:\n upgrade the privacy properties of existing applications, such as cryptographic wallets, VPNs, payment systems, chat, medical records, blockchains, exchanges, markets, DAOs or other allocation systems. enable completely new types of applications built from the ground up with privacy at their core  Apps talk to the Nym network by connecting to gateway nodes. Applications may go online and offline; the gateway provides a sort of mailbox where apps can receive their messages.\nThere are two basic kinds of privacy enhanced applications:\n user facing apps running on mobile or desktop devices. These will typically expose a user interface (UI) to a human user. These might be existing apps such as crypto wallets that communicate with Nym via our SOCKS5 proxy, or entirely new apps. Service Providers, which will usually run on a server, and take actions on behalf of users without knowing who they are.  Service Providers (SPs) may interact with external systems on behalf of a user. For example, an SP might submit a Bitcoin, Ethereum or Cosmos transaction, proxy a network request, talk to a chat server, or provide anonymous access to a medical system such as a privacy-friendly coronavirus tracker.\nThere is also a special category of Service Provider, namely SPs that do not visibly interact with any external systems. You might think of these as crypto-utopiapps: they\u0026rsquo;re doing something, but it\u0026rsquo;s not possible from outside to say with any certainty what their function is, or who is interacting with them.\nAll apps talk with Nym gateway nodes using Sphinx packets and a small set of simple control messages. These messages are sent to gateways over websockets. Each app client has a long-lived relationship with its gateway; Nym defines messages for clients registering and authenticating with gateways, as well as sending encrypted Sphinx packets.\nWe are currently focused on providing privacy for blockchain systems. But our ambitions are wider. In the medium term, we are actively working to bring together a range of new technologies that can enable strong privacy for the whole internet. There have not been many new widely-adopted privacy technologies to help internet users in the past 15 years. We are working hard to change that.\nCurrent Status The mixnet and validators are now working.\nMixnet APIs have mostly stabilized, and at this point it\u0026rsquo;s possible to start building applications.\nValidators are now working in their most basic form, and include a reputation token called nym. Later, validators will also generate Coconut credentials.\nThere is currently a native mixnet client written in Rust. It runs in standalone fashion on desktops or servers. You can use this for connecting desktop or server apps to the Nym network, using any language that speaks websockets.\nA webassembly client also exists. Webassembly clients can be used within browser or mobile apps, and again communicate with gateways via websockets. The webassembly client is not complete (it does not yet send cover traffic), but it is working to a point where you should be able to use it for application development. Cover traffic, when it is set up, will happen transparently and you shouldn\u0026rsquo;t need to worry about it as a Nym app developer.\nLastly, a SOCKS5 client and Service Provider (called nym-network-requester) makes it easy to retrofit cryptocurrency wallets and other existing SOCKS-compatible applications to use Nym privacy infrastructure.\nIn the next few sections, we\u0026rsquo;ll look at network privacy and access privacy in more detail.\n"},{"uri":"https://nymtech.net/docs/community/code-of-conduct/","title":"Code of Conduct","tags":[],"description":"Nym is committed to providing a friendly, safe and welcoming environment for all. Here&#39;s our code of conduct, please follow it if you&#39;d like to participate in our community.","content":"We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.\nPlease avoid using overtly sexual aliases or other nicknames that might detract from a friendly, safe and welcoming environment for all.\nPlease be kind and courteous. There’s no need to be mean or rude.\nRespect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.\nPlease keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.\nWe will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behaviour. We interpret the term “harassment” as including the definition in the Citizen Code of Conduct; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don’t tolerate behaviour that excludes people in socially marginalized groups.\nPrivate harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the Rust moderation team immediately. Whether you’re a regular contributor or a newcomer, we care about making this community a safe place for you and we’ve got your back.\nLikewise any spamming, trolling, flaming, baiting or other attention-stealing behaviour is not welcome.\n"},{"uri":"https://nymtech.net/docs/run-nym-nodes/incentives/","title":"Incentives","tags":[],"description":"Why should you run Nym nodes?","content":"We will get into building the Nym codebase and running nodes in the next section. Before we do so, a note on token incentives.\nThe Nym network has some of the same overall goals as Tor. But we want to enable Nym to scale in response to increased demand (and shrink when demand drops, so as not to waste resources). To do this in a decentralized way, nodes are included in the network based on cryptocurrency bonding, and a system of delegated staking.\nWe are now starting to test out the incentives structure for running Nym nodes. For the Finney testnet, Nym testnet wallet holders who run nodes or delegate stake to nodes will receive (valueless) testnet tokens, the hal, which runs on our Cosmos-based blockchain validators.\nThe structure of token rewards will be under experimentation throughout the course of Finney, and we will be altering them fairly frequently to run experiments and get community feedback. Finney Testnet rewards may not reflect how the incentives structure will work on mainnet.\nWe will be detailing the rewards structure in a series of blog posts over the course of the Finney testnet, and we will eventually document token rewards here.\n"},{"uri":"https://nymtech.net/docs/run-nym-nodes/","title":"Run Nym Nodes","tags":[],"description":"How to build the Nym platform. Nym is relatively simple to build and run on Mac OS X, Linux, and Windows.","content":"Installing pre-built binaries The Nym release page at https://github.com/nymtech/nym/releases has pre-built binaries which should work on Ubuntu 20.04. These are not guaranteed to work on all systems.\nLater, when we\u0026rsquo;re focused more on things like packaging, we will ensure that all components get built for all operating systems.\nIf the pre-built binaries don\u0026rsquo;t work or are unavailable for your system, you will need to build the platform yourself.\nBuilding Nym Nym has two main codebases:\n the Nym platform (build instructions), written in Rust. This contains all of our code except for the validators. the Nym validators (build instructions), written in Go.  "},{"uri":"https://nymtech.net/docs/run-nym-nodes/build-nym/","title":"Building Nym","tags":[],"description":"How to build the Nym platform. Nym is relatively simple to build and run on Mac OS X, Linux, and Windows.","content":" This page details how to build the main Nym platform code, in Rust. If you want to build and run a validator, go here instead.\n Nym runs on Mac OS X, Linux, and Windows. Windows should be considered experimental - it works fine if you\u0026rsquo;re an app developer but isn\u0026rsquo;t recommended for running nodes.\nPrerequisites:\n on Debian/Ubuntu: sudo apt install pkg-config build-essential libssl-dev curl jq. Rust 1.47 or later, with cargo. Stable works.  We recommend using the Rust shell script installer. Installing cargo from your package manager (e.g. apt) is not recommended as the packaged versions are usually too old.\nIf you really don\u0026rsquo;t want to use the shell script installer, the Rust installation docs contain instructions for many platforms.\nTo download and build the Nym platform (mixnode, gateway and clients):\nrustup update git clone https://github.com/nymtech/nym.git cd nym git reset --hard # in case you made any changes on your branch git pull # in case you've checked it out before # # Note: the default branch you clone from Github, `develop`, is guaranteed to be # broken and incompatible with the running testnet at all times. You *must* # `git checkout tags/v0.10.0` in order to join the testnet. # git checkout tags/v0.10.0 cargo build --release The above commands will compile binaries into the nym/target/release directory.\nQuite a bit of stuff gets built. The key working parts are:\n the mixnode: nym-mixnode the gateway node: nym-gateway the websocket client: nym-client the socks5 client: nym-socks5-client the network requester: nym-network-requester  If you run into trouble, please ask for help in the channel nymtech.friends#general on KeyBase.\n "},{"uri":"https://nymtech.net/docs/community/licensing/","title":"Licensing","tags":[],"description":"Nym is free software released under the Apache License V2","content":"Nym is Free Software released under the Apache License V2.\nAll of the contributions of the Nym core developers are (c) Nym Technologies SA. If you are interested in talking to us about other licenses, please get in touch.\n"},{"uri":"https://nymtech.net/docs/build-apps/choose-a-client/","title":"Choose a client","tags":[],"description":"There are multiple kinds of Nym client. Each is useful in different situations. Here&#39;s how to choose.","content":"In the previous section, we got a general overview of the application flow when you\u0026rsquo;re building Nym-enabled apps. Now it\u0026rsquo;s time to understand a bit about how to structure your app by choosing a Nym client.\nUnderstanding Nym clients A large proportion of the Nym mixnet\u0026rsquo;s functionality is implemented client-side, including:\n determining network topology - what mixnodes exist, what their keys are, etc. registering with a gateway authenticating to a gateway receiving and decrypting messages from the gateway creation of layer-encrypted Sphinx packets sending Sphinx packets with real messages sending Sphinx packet cover traffic when no real messages are being sent  In the next few sections we will discuss how to integrate Nym clients into your apps.\nTypes of Nym clients At present, there are three Nym clients:\n the native client the webassembly client the SOCKS5 client  You need to choose which one you want incorporate into your app. Which one you use will depend largely on your preferred programming style and the purpose of your app.\nThe websocket client Your first option is the websocket client (nym-client). This is a compiled program that can run on Linux, Mac OS X, and Windows machines. It runs as a persistent process on a desktop or server machine. You can connect to it from any language that supports websockets.\nThe webassembly client If you\u0026rsquo;re working in JavaScript, or building an edge computing app, you\u0026rsquo;ll likely want to choose the webassembly client. We expect that many client apps will be built using the webassembly client. It\u0026rsquo;s packaged and available on the npm registry, so you can npm install it into your JavaScript or TypeScript application.\nThe SOCKS5 client This client is useful for allowing existing applications to use the Nym mixnet without any code changes. All that\u0026rsquo;s necessary is that they can use the SOCKS5 proxy protocol (which many applications can - crypto wallets, browsers, chat applications etc). It\u0026rsquo;s less flexible as a way of writing custom applications than the other clients.\nCommonalities between clients All Nym client packages present basically the same capabilities to the privacy application developer. They need to run as a persistent process in order to stay connected and ready to receive any incoming messages from their gateway nodes. They register and authenticate to gateways, and encrypt Sphinx packets.\n"},{"uri":"https://nymtech.net/docs/run-nym-nodes/mixnodes/","title":"Mixnodes","tags":[],"description":"Mixnodes accept Sphinx packets, shuffle packets together, and forward them onwards, providing strong privacy for internet users.","content":" The Nym mixnode was built in the building nym section. If you haven\u0026rsquo;t yet built Nym and want to run the code, go there first.\n To join the Nym testnet as a mixnode, copy the nym-mixnode binary from the target/release directory up to your server (or compile it on the server).\nUpgrading from an earlier version If you have already been running a node on the Nym network v0.9.2, you can use the upgrade command to upgrade your configs in place.\n./nym-mixnode upgrade --id your-node-id Initialize a mixnode If you are new to Nym, here\u0026rsquo;s how you initialize a mixnode:\n./nym-mixnode init --id winston-smithnode --host $(curl ifconfig.me) --location YourCity To participate in the Nym testnet, --host must be publicly routable on the internet. It can be either an Ipv4 or IPv6 address. Your node must be able to send TCP data using both IPv4 and IPv6 (as other nodes you talk to may use either protocol). The above command gets your IP automatically using an external service $(curl ifconfig.me). Enter it manually if you don\u0026rsquo;t have curl installed.\nThe --location flag is optional but helps us debug the testnet.\nYou can pick any --id you want.\nWhen you run init, configuration files are created at ~/.nym/mixnodes/\u0026lt;your-id\u0026gt;/.\nThe init command will refuse to destroy existing mixnode keys.\nClaim your mixnode in Telegram so you can get tokens Testnet Finney, which works with version 0.10.x of the Nym mixnode, introduces the concept of \u0026ldquo;mixnode bonding\u0026rdquo;. Each mixnode operator needs to get tokens, and bond them in our blockchain, in order to enter Testnet Finney.\nTo claim your mixnode, run the sign command, and provide your Telegram username:\n./nym-mixnode sign --id winston-smithnode --text @your-telegram-username _ __ _ _ _ __ ___ | \u0026#39;_ \\| | | | \u0026#39;_ \\ _ \\  | | | | |_| | | | | | | |_| |_|\\__, |_| |_| |_| |___/ (mixnode - version 0.10.0) Signing the text \u0026#34;@your-telegram-username\u0026#34; using your mixnode\u0026#39;s Ed25519 identity key... Signature is: 4Yo4ZkUBxREJapzf7AxLPodQXic4cfbNziJMLxsftTQsVdm5XKUg8be8ErXhnHunsnmz8EZvuGLwSD98PifCad1f You can claim your mixnode in Telegram by talking to our bot. To do so: * go to the \u0026#39;@nymchan_help_chat\u0026#39; channel * copy the following line of text, and paste it into the channel /claim 7xdQ1USuNEZN4WbbiZFPfd59HTqFeNkxpu4zWrYGtmTz 4Yo4ZkUBxREJapzf7AxLPodQXic4cfbNziJMLxsftTQsVdm5XKUg8be8ErXhnHunsnmz8EZvuGLwSD98PifCad1f Then enter the @nymchan_help_chat channel on Telegram and talk to the bot to associate your Telegram username with your mixnode key:\n/claim 7xdQ1USuNEZN4WbbiZFPfd59HTqFeNkxpu4zWrYGtmTz 4Yo4ZkUBxREJapzf7AxLPodQXic4cfbNziJMLxsftTQsVdm5XKUg8be8ErXhnHunsnmz8EZvuGLwSD98PifCad1f This proves to the bot that your username owns the mixnode.\nNext, go to the Finney Testnet web wallet and create a Nym address. It will look something like hal1rytmasg5kavx4xasa0zg0u69jus8fn0r5j7nnt. Be sure to write down your mnemonic!\nOnce you have a Nym testnet address, ask the Telegram bot for tokens:\n/faucet hal1rytmasg5kavx4xasa0zg0u69jus8fn0r5j7nnt # your address goes here! The bot will send you tokens so that you can bond your mixnode. First, you\u0026rsquo;ll need to run it.\nRun the mixnode ./nym-mixnode run --id winston-smithnode\nYou should see a nice clean startup:\n | '_ \\| | | | '_ \\ _ \\ | | | | |_| | | | | | | |_| |_|\\__, |_| |_| |_| |___/ (mixnode - version 0.10.0) Starting mixnode winston-smithnode... Directory server [presence]: http://testnet-finney-validator.nymtech.net:1317 Directory server [metrics]: http://testnet-metrics.nymtech.net:8080 Listening for incoming packets on \u0026lt;your-ip\u0026gt;:1789 Announcing the following socket address: \u0026lt;your-ip\u0026gt;:1789 To bond your mixnode, go to https://web-wallet-finney.nymtech.net/. You will need to provide the following: Identity key: 7xdQ1USuNEZN4WbbiZFPfd59HTqFeNkxpu4zWrYGtmTz Sphinx key: 6T6PpSAzaiHMKJQPKPABXzppxLtUDB3TB4ChM16t3oYP Host: \u0026lt;your-ip\u0026gt;:1789 Layer: 3 Location: [physical location of your node's server] Version: 0.10.0 Once the tokens arrive, go back to the web wallet and fill in the mixnode bonding form, using your mixnode\u0026rsquo;s info.\nIf everything worked, you\u0026rsquo;ll see your node running at https://testnet-finney-explorer.nymtech.net.\nNote that your node\u0026rsquo;s public identity key is displayed during startup, you can use it to identify your node in the list.\nKeep reading to find our more about configuration options or troubleshooting if you\u0026rsquo;re having issues. There are also some tips for running on AWS and other cloud providers, some of which require minor additional setup.\nIf you run into trouble, please ask for help in the channel nymtech.friends#general on KeyBase.\n Have a look at the saved configuration files to see more configuration options.\nMaking a systemd startup script Although it\u0026rsquo;s not totally necessary, it\u0026rsquo;s useful to have the mixnode automatically start at system boot time. Here\u0026rsquo;s a systemd service file to do that:\n[Unit] Description=Nym Mixnode (0.10.0) [Service] User=nym LimitNOFILE=65536 ExecStart=/home/nym/nym-mixnode run --id mix0100 KillSignal=SIGINT Restart=on-failure RestartSec=30 StartLimitInterval=350 StartLimitBurst=10 [Install] WantedBy=multi-user.target Put the above file onto your system at /etc/systemd/system/nym-mixnode.service.\nChange the path in ExecStart to point at your mixnode binary (nym-mixnode), and the User so it is the user you are running as.\nIf you have built nym on your server, and your username is jetpanther, then the start command might look like this:\nExecStart=/home/jetpanther/nym/target/release/nym-mixnode run --id your-id. Basically, you want the full /path/to/nym-mixnode run --id whatever-your-node-id-is\nThen run:\nsystemctl enable nym-mixnode.service Start your node:\nservice nym-mixnode start This will cause your node to start at system boot time. If you restart your machine, the node will come back up automatically.\nYou can also do service nym-mixnode stop or service nym-mixnode restart.\nNote: if you make any changes to your systemd script after you\u0026rsquo;ve enabled it, you will need to run:\nsystemctl daemon-reload This lets your operating system know it\u0026rsquo;s ok to reload the service configuration.\nSet the ulimit If you are not running nym-mixnode with systemd as above with LimitNOFILE=65536 then you will run into issues. You must set your ulimit well above 1024 or your node won\u0026rsquo;t work properly in the testnet. To test the ulimit of your mixnode:\ngrep -i \u0026quot;open files\u0026quot; /proc/$(ps -A -o pid,cmd|grep nym-mixnode | grep -v grep |head -n 1 | awk '{print $1}')/limits You\u0026rsquo;ll get back the hard and soft limits, something like this:\nMax open files 65536 65536 files \nThis means you\u0026rsquo;re good and your node will not encounter any ulimit related issues.\nHowever;\nIf either value is 1024, you must raise the limit. To do so, either edit the systemd service file and add LimitNOFILE=65536 and reload the daemon: systemctl daemon-reload as root\nor execute this as root for system-wide setting of ulimit:\necho \u0026quot;DefaultLimitNOFILE=65535\u0026quot; \u0026gt;\u0026gt; /etc/systemd/system.conf Reboot your machine and restart your node. When it comes back, do cat /proc/$(pidof nym-mixnode)/limits | grep \u0026quot;Max open files\u0026quot; again to make sure the limit has changed to 65535.\nChanging the DefaultLimitNOFILE and rebooting should be all you need to do. But if you want to know what it is that you just did, read on.\nLinux machines limit how many open files a user is allowed to have. This is called a ulimit.\nulimit is 1024 by default on most systems. It needs to be set higher, because mixnodes make and receive a lot of connections to other nodes.\nSymptoms of ulimit problems If you see any references to Too many open files in your logs:\nFailed to accept incoming connection - Os { code: 24, kind: Other, message: \u0026quot;Too many open files\u0026quot; } This means that the operating system is preventing network connections from being made. Raise your ulimit.\nChecking that your node is mixing correctly Once you\u0026rsquo;ve started your mixnode and it connects to the testnet validator, your node will automatically show up in the Nym testnet explorer.\nFor more details see Troubleshooting FAQ\nViewing command help See all available options by running:\n./nym-mixnode --help Subcommand help is also available, e.g.:\n./nym-mixnode upgrade --help Virtual IPs, Google, AWS, and all that On some services (e.g. AWS, Google), the machine\u0026rsquo;s available bind address is not the same as the public IP address. In this case, bind --host to the local machine address returned by ifconfig, but also specify --announce-host with the public IP. Please make sure that you pass the correct, routable --announce-host.\nFor example, on a Google machine, you may see the following output from the ifconfig command:\nens4: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1460 inet 10.126.5.7 netmask 255.255.255.255 broadcast 0.0.0.0 ... The ens4 interface has the IP 10.126.5.7. But this isn\u0026rsquo;t the public IP of the machine, it\u0026rsquo;s the IP of the machine on Google\u0026rsquo;s internal network. Google uses virtual routing, so the public IP of this machine is something else, maybe 36.68.243.18.\nnym-mixnode init --host 10.126.5.7, inits the mixnode, but no packets will be routed because 10.126.5.7 is not on the public internet.\nTrying nym-mixnode init --host 36.68.243.18, you\u0026rsquo;ll get back a startup error saying AddrNotAvailable. This is because the mixnode doesn\u0026rsquo;t know how to bind to a host that\u0026rsquo;s not in the output of ifconfig.\nThe right thing to do in this situation is nym-mixnode init --host 10.126.5.7 --announce-host 36.68.243.18.\nThis will bind the mixnode to the available host 10.126.5.7, but announce the mixnode\u0026rsquo;s public IP to the directory server as 36.68.243.18. It\u0026rsquo;s up to you as a node operator to ensure that your public and private IPs match up properly.\nMixnode Hardware Specs For the moment, we haven\u0026rsquo;t put a great amount of effort into optimizing concurrency to increase throughput. So don\u0026rsquo;t bother provisioning a beastly server with many cores.\n Processors: 2 cores are fine. Get the fastest CPUs you can afford. RAM: Memory requirements are very low - typically a mixnode may use only a few hundred MB of RAM. Disks: The mixnodes require no disk space beyond a few bytes for the configuration files  This will change when we get a chance to start doing performance optimizations in a more serious way. Sphinx packet decryption is CPU-bound, so once we optimise, more fast cores will be better.\n"},{"uri":"https://nymtech.net/docs/overview/network-privacy/","title":"Network Privacy","tags":[],"description":"Nym ensures network privacy using layer encrypted Sphinx packets and a Loopix mixnet.","content":"When you send data across the internet, it can be recorded by a wide range of observers: your ISP, internet infrastructure providers, large tech companies, and governments.\nEven if the content of a network request is encrypted, observers can still see that data was transmitted, its size, frequency of transmission, and gather metadata from unencrypted parts of the data (such as IP routing information). Adversaries may then combine all the leaked information to probabilistically de-anonymize users.\nClaudia\u0026rsquo;s lightning talk from Dappcon 2019 in Berlin gives a general overview of network privacy.\n  The Nym mixnet provides very strong security guarantees against this sort of surveillance. It packetizes and mixes together IP traffic from many users inside a mixnet: a decentralized system composed of many mixnodes.\nA mixnet can be used to secure blockchain or non-blockchain systems. Things like crypto-currency wallets are a natural fit for mixnets; but so are non-blockchain things like chat systems, or systems for which you want wide usage but strong privacy guarantees for users, such as coronavirus tracking apps.\nIf you\u0026rsquo;re into comparisons, the Nym mixnet is conceptually similar to other systems such as Tor, but provides improved protections against end-to-end timing attacks which can de-anonymize users. When Tor was first fielded, in 2002, those kinds of attacks were regarded as science fiction. But the future is now here.\nLoopix, the Nym mixnet To meet these new threats, the Nym mixnet re-orders encrypted, indistinguishable Sphinx packets as they travel through the mixnodes. Our mixnet design based on the Loopix Anonymity System, somewhat modified to provide better quality of service guarantees. Another of our researchers, Ania, is an author of the Loopix academic paper.\nThis short video features Ania discussing the Loopix mixnet design in detail at USENix 2017.\n  There is a very non-technical introduction to mixnets in the blog post A Simple Introduction to Mixnets. But here\u0026rsquo;s the boiled-down explanation.\nAssume a God-like adversary who can watch every packet on the network, record everything, and analyze everything in real-time. Is it possible to have private communications in such an environment? Intuitively, the answer is no: the adversary can watch every packet as it travels through the network, and progressively identify users with a high degree of success using probabilistic techniques.\nThe Nym mixnet solves this problem by mixing messages inside network nodes which are opaque to the adversary. Each packet is layer encrypted, and binary-padded so that it\u0026rsquo;s indistinguishable from all other packets. Incoming packets are \u0026ldquo;mixed\u0026rdquo; with all other messages inside the node. That is, the node strips one layer of packet encryption, and adds a small random transmission delay, so that messages are not emitted in the same order as which they arrived.\nNext, the message is sent to another mix node, decrypted and mixed again, then to a third mixnode for further mixing. Finally, the message is delivered to its destination gateway.\nAs long as there\u0026rsquo;s enough traffic flowing through the nodes, even an adversary who can record the whole internet will not be able to trace the packet flow through the system.\nThe Nym mixnet mitigates against packet-dropping attacks by malicious nodes, and ensures quality-of-service, via loop traffic. Clients send messages which loop back to themselves. This allows clients to assure themselves that messages are being delivered properly. It also provides cover traffic to ensure that enough messages are going through the system to provide privacy.\nPrivacy Enhanced Applications (Peaps) that need to defend against network-level monitoring can use the Nym mixnet.\nThe end result is that adversaries are unable to monitor Privacy Enhanced Applications (Peaps) using Nym even if they can record all internet traffic. The adversary can tell that a user\u0026rsquo;s Peap has connected to the mixnet; beyond that, it\u0026rsquo;s impossible to say whether they are doing encrypted chat, file transfer, or interacting with another Peap.\n"},{"uri":"https://nymtech.net/docs/run-nym-nodes/validators/","title":"Validators","tags":[],"description":"Nym Validators provide privacy-enhanced credentials based on the testimony of a set of decentralized, blockchain-based issuing authorities.","content":"Nym validators secure the network with a staking token, defending the network from Sybil attacks.\nValidators also provide privacy-enhanced credentials based on the testimony of a set of decentralized, blockchain-based issuing authorities. Nym validators use a signature scheme called Coconut to issue credentials. This allows privacy apps to generate anonymous resource claims through decentralised authorities, then use them with Service Providers.\nThe validator is built using Cosmos SDK and Tendermint, with a CosmWasm smart contract controlling the directory service, node bonding, and delegated mixnet staking.\nBuilding the Nym validator Prerequisites  Go \u0026gt;= v1.15  Go can be installed via the following commands (taken from the Agoric SDK docs):\n# First remove any existing old Go installation sudo rm -rf /usr/local/go # Install correct Go version curl https://dl.google.com/go/correct.go.version.linux-amd64.tar.gz | sudo tar -C/usr/local -zxvf - # Update environment variables to include go cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; \u0026gt;\u0026gt;$HOME/.profile export GOROOT=/usr/local/go export GOPATH=$HOME/go export GO111MODULE=on export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin EOF source $HOME/.profile Remember to replace correct.go.version with the version of your choice from the Go releases page. For example:\ncorrect.go.version.linux-amd64.tar.gz =\u0026gt; go1.15.7.linux-amd64.tar.gz\nVerify Go is installed with:\ngo version # Should return: go version go1.15.7 linux/amd64  gcc  gcc can be installed with:\nsudo apt install build-essential # Optional additional manual pages can be installed with: sudo apt-get install manpages-dev Verify gcc is installed with:\ngcc --version Which should return something like:\ngcc (Ubuntu 7.4.0-1ubuntu1~18.04) 7.4.0 Copyright (C) 2017 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Building your validator We use the wasmd version of the Cosmos validator to run our blockchain. Run this to clone, compile, and build it:\nWASMD_VERSION=v0.14.1 BECH32_PREFIX=hal git clone https://github.com/CosmWasm/wasmd.git cd wasmd git checkout ${WASMD_VERSION} mkdir build go build -o build/nymd -mod=readonly -tags \u0026#34;netgo,ledger\u0026#34; -ldflags \u0026#34;-X github.com/cosmos/cosmos-sdk/version.Name=nymd -X github.com/cosmos/cosmos-sdk/version.AppName=nymd -X github.com/CosmWasm/wasmd/app.NodeDir=.nymd -X github.com/cosmos/cosmos-sdk/version.Version=${WASMD_VERSION}-X github.com/cosmos/cosmos-sdk/version.Commit=1920f80d181adbeaedac1eeea1c1c6e1704d3e49 -X github.com/CosmWasm/wasmd/app.Bech32Prefix=${BECH32_PREFIX}-X \u0026#39;github.com/cosmos/cosmos-sdk/version.BuildTags=netgo,ledger\u0026#39;\u0026#34; -trimpath ./cmd/wasmd # noqa line-length At this point, you will have a copy of the nymd binary in your build/ directory. Test that it\u0026rsquo;s compiled properly by running:\n./build/nymd You should see nymd help text print out.\nBoth the nymd and libwasmvm.so shared object library binary have been compiled. libwasmvm.so is the wasm virtual machine which is needed to execute Nym smart contracts.\n If you have compiled these files locally you need to upload both of them to the server on which the validator will run. If you have instead compiled them on the server skip to the step outlining setting LD_LIBRARY PATH below. To locate these files on your local system run:\n WASMVM_SO=$(ldd build/nymd | grep libwasmvm.so | awk \u0026#39;{ print $3 }\u0026#39;) ls ${WASMVM_SO} This will output something like:\n\u0026#39;/home/username/go/pkg/mod/github.com/!cosm!wasm/wasmvm@v0.13.0/api/libwasmvm.so\u0026#39; When you upload your nymd binary, you\u0026rsquo;ll need to tell it where libwasmvm.so is when you start your validator, or nymd will not run. If you have compiled them on your server then this is not necessary, as the compiled nymd already has access to libwasmvm.so.\nAlternatively, you can check out the repository for nym at https://github.com/nymtech/nym and use the tag for the current release with:\ngit clone https://github.com/nymtech/nym.git cd nym git reset --hard # in case you made any changes on your branch git pull # in case you\u0026#39;ve checked it out before git checkout tags/v0.10.0 Inside the folder validator you will find the precompiled binaries to use.\nUpload both nymd and libwasmvm.so to your validator machine. If you attempt to run ./nymd on your server, you\u0026rsquo;ll likely see an error if nymd can\u0026rsquo;t find libwasmvm.so:\n./nymd: error while loading shared libraries: libwasmvm.so: cannot open shared object file: No such file or directory You\u0026rsquo;ll need to set LD_LIBRARY_PATH in your user\u0026rsquo;s ~/.bashrc file, and add that to our path. Replace /home/youruser/path/to/nym/binaries in the command below to the locations of nymd and libwasmvm.so and run it. If you have compiled these on the server, they will be in the build/ folder:\nNYM_BINARIES=/home/youruser/path/to/nym/binaries echo \u0026#39;export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:\u0026#39;NYM_BINARIES \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export PATH=$PATH:\u0026#39;${NYM_BINARIES} \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc Test everything worked:\nnymd This should return the regular nymd help text.\nInitializing your validator Prerequisites:\n FQDN Domain name IPv4 and IPv6 connectivity  Choose a name for your validator and use it in place of yourname in the following command:\nnymd init yourname --chain-id testnet-finney At this point, you have a new validator, with its own genesis file located at $HOME/.nymd/config/genesis.json. You will need to replace the contents of that file that with Nym\u0026rsquo;s testnet-finney genesis file.\nYou can use the following command to download the one for Finney with:\nwget -O $HOME/.nymd/config/genesis.json https://nymtech.net/testnets/finney/genesis.json config.toml setup Add the Nym validator as a persistent peer so that your validator can start pulling blocks from the rest of the network, by editing the following config options in $HOME/.nymd/config/config.toml to match the information below:\n cors_allowed_origins = [\u0026quot;*\u0026quot;] allows the web wallet to make HTTPS requests to your validator. persistent_peers = \u0026quot;e7163ea63219504344c669164d083f52434f382b@testnet-finney-validator.nymtech.net:26656\u0026quot; allows your validator to start pulling blocks from other validators create_empty_blocks = false may save a bit of space  Optionally, if you want to enable Prometheus metrics then the following must also match in the config.toml:\n prometheus = true prometheus_listen_addr = \u0026quot;:26660\u0026quot;  And if you wish to add a human-readable moniker to your node:\n moniker = \u0026quot;yourname\u0026quot;  Finally, if you plan on using Cockpit on your server, change the grpc port from 9090 as this is the port used by Cockpit.\napp.toml setup In the file $HOME/.nymd/config/app.toml, set the following values:\n minimum-gas-prices = \u0026quot;0.025uhal\u0026quot; enable = true in the [api] section to get the API server running  Setting up your validator\u0026rsquo;s admin user: You\u0026rsquo;ll need an admin account to be in charge of your validator. Set that up with:\nnymd keys add nymd-admin This will add keys for your administrator account to your system\u0026rsquo;s keychain.\nThe command output should look something like:\n$ nymd keys add nymd-admin Enter keyring passphrase: password must be at least 8 characters Enter keyring passphrase: Re-enter keyring passphrase: - name: nymd-admin type: local address: hal1x4twq82ew2c49ctr36mafksyrtnxwvrkey939u pubkey: halpub1addwnpepqdfcf5786qry8g8ef9nad5vnl0rs5cmkcywzrwwvvdye27ktjmqw2ygr2hr mnemonic: \u0026#34;\u0026#34; threshold: 0 pubkeys: [] **Important** write this mnemonic phrase in a safe place. It is the only way to recover your account if you ever forget your password. design payment apple input doll left badge never toe claw coconut neither travel side castle know plate unit mercy weekend pelican stay fortune road As the instructions say, remember to write down your mnemonic.\nYou can get the admin account\u0026rsquo;s address with:\nnymd keys show nymd-admin -a Type in your keychain password, not the mnemonic, when asked. The output should look something like this:\nhal1x4twq82ew2c49ctr36mafksyrtnxwvrkey939u Starting your validator Everything should now be ready to go. You\u0026rsquo;ve got the validator set up, all changes made in config.toml and app.toml, the Nym genesis file copied into place (replacing the initial auto-generated one). Now let\u0026rsquo;s validate the whole setup:\nnymd validate-genesis If this check passes, you should receive the following output:\nFile at /path/to/.nymd/config/genesis.json is a valid genesis file  If this test did not pass, check that you have replaced the contents of /path/to/.nymd/config/genesis.json with that of the testnet-finney genesis file.\n Before starting the validator, we will need to open the firewall ports (adapt if not using firewalld):\nfor port in 1317/tcp 9090/tcp 26656/tcp 22/tcp 26660/tcp 80/tcp 443/tcp; do firewall-cmd --add-port=${port} firewall-cmd --add-port=${port} --permanent done Ports 22, 80, and 443 are for ssh, http, and https connections respectively. The rest of the ports are documented here.\n If you are planning to use Cockpit on your validator server then you will have defined a different grpc port in your config.toml above: remember to open this port as well.\n Start the validator:\nnymd start Once your validator starts, it will start requesting blocks from other validators. This may take several hours. Once it\u0026rsquo;s up to date, you can issue a request to join the validator set:\nPUB_KEY=$(/home/youruser/path/to/nym/binaries/nymd tendermint show-validator) # e.g. halvalconspub1zcjduepqzw38hj6edjc5wldj3d37hwc4savn0t95uakhy6tmeqqz5wrfmntsnyehsq MONIKER=\u0026#34;nym-secondary\u0026#34; # whatever you called your validator FROM_ACCOUNT=\u0026#34;nymd-admin\u0026#34; # your keychain name nymd tx staking create-validator \\ --amount=10000000stake \\ --fees=5000uhal \\ --pubkey=\u0026#34;${PUB_KEY}\u0026#34; \\ --moniker=${MONIKER} \\ --chain-id=testnet-finney \\ --commission-rate=\u0026#34;0.10\u0026#34; \\ --commission-max-rate=\u0026#34;0.20\u0026#34; \\ --commission-max-change-rate=\u0026#34;0.01\u0026#34; \\ --min-self-delegation=\u0026#34;1\u0026#34; \\ --gas=\u0026#34;auto\u0026#34; \\ --gas-adjustment=1.15 \\ --from=${FROM_ACCOUNT} \\ --node https://testnet-finney-validator.nymtech.net:443 You\u0026rsquo;ll need stake coins for this.\nNote: we are currently working towards building up a closed set of reputable validators. You can ask us for coins to get in, but please don\u0026rsquo;t be offended if we say no - validators are part of our system\u0026rsquo;s core security and we are starting out with people we already know or who have a solid reputation.\nIf you want to edit some details for your node you will use a command like this:\nnymd tx staking edit-validator --chain-id=testnet-finney --moniker=${MONIKER} --details=\u0026#34;Nym validator\u0026#34; --security-contact=\u0026#34;YOUREMAIL\u0026#34; --identity=\u0026#34;XXXXXXX\u0026#34; --gas=\u0026#34;auto\u0026#34; --gas-adjustment=1.15 --from=${FROM_ACCOUNT} --fees 2000uhal With above command you can specify the gpg key last numbers (as used in keybase) as well as validator details and your email for security contact~\nAutomating your validator with systemd You will most likely want to automate your validator restarting if your server reboots. Below is a systemd unit file to place at /etc/systemd/system/nymd.service:\n[Unit] Description=Nymd (0.10.0) [Service] User=nym # change to your user Type=simple Environment=\u0026#34;LD_LIBRARY_PATH=/home/youruser/path/to/nym/binaries\u0026#34; # change to correct path ExecStart=/home/youruser/path/to/nym/binaries/nymd start # change to correct path Restart=on-failure RestartSec=30 StartLimitInterval=350 StartLimitBurst=10 [Install] WantedBy=multi-user.target Proceed to start it with:\nsystemctl daemon-reload # to pickup the new unit file systemctl enable nymd # to enable the service systemctl start nymd # to actually start the service journalctl -f # to monitor system logs showing the service start Installing and configuring nginx for HTTPS Setup Nginx is an open source software used for operating high-performance web servers. It allows us to set up reverse proxying on our validator server to improve performance and security.\nInstall nginx and enable \u0026ldquo;Nginx Full\u0026rdquo; in your firewall.\nCheck nginx is running via systemctl:\nsystemctl status nginx Which should return:\n● nginx.service - A high performance web server and a reverse proxy server Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) Active: active (running) since Fri 2018-04-20 16:08:19 UTC; 3 days ago Docs: man:nginx(8) Main PID: 2369 (nginx) Tasks: 2 (limit: 1153) CGroup: /system.slice/nginx.service ├─2369 nginx: master process /usr/sbin/nginx -g daemon on; master_process on; └─2380 nginx: worker process Configuration Proxying your validator\u0026rsquo;s port 26657 to nginx port 80 can then be done by including the following in /etc/nginx/conf.d/validator.conf:\nserver { listen 80; listen [::]:80; server_name {{ domain }}; location / { proxy_pass http://127.0.0.1:26657; proxy_set_headerX-Real-IP $remote_addr; proxy_set_headerHost $host; proxy_set_headerX-Real-IP $remote_addr; } } Followed by:\nsudo apt install certbot nginx python3 certbot --nginx -d nym-validator.yourdomain.com -m you@yourdomain.com --agree-tos --noninteractive --redirect These commands will get you an HTTPS encrypted nginx proxy in front of the API.\nIn the next testnet we will be focusing more on things such as validator TLS and sentry nodes.\nUnjailing your validator If, for some reason, your validator gets jailed, you can fix it with the following command:\nnymd tx slashing unjail \\  --broadcast-mode=block \\  --from=${FROM_ACCOUNT} \\  --chain-id=testnet-finney \\  --gas=auto \\  --gas-adjustment=1.4 \\  --fees=7000uhal Day 2 operations with your validator As part of the execution of the validator, it will be able to get some rewards.\nWith this command, we can query our outstanding rewards:\nnymd query distribution validator-outstanding-rewards \u0026lt;halvaloperaddress\u0026gt; Using the values obtained from the previous command, you can withdraw all rewards with:\nnymd tx distribution withdraw-rewards \u0026lt;halvaloperaddress\u0026gt; --from ${FROM_ACCOUNT} --keyring-backend=os --chain-id=\u0026#34;testnet-finney\u0026#34; --gas=\u0026#34;auto\u0026#34; --gas-adjustment=1.15 --commission --fees 5000uhal You can check your current balances with:\nnymd query bank balances hal\u0026lt;address\u0026gt; For example:\nbalances: - amount: \u0026#34;22976200\u0026#34; denom: stake - amount: \u0026#34;919376\u0026#34; denom: uhal pagination: next_key: null total: \u0026#34;0\u0026#34; You can, of course, stake back the available balance to your validator with the following command:\nnymd tx staking delegate \u0026lt;halvaloperaddress\u0026gt; \u0026lt;amount\u0026gt;stake--from ${FROM_ACCOUNT} --keyring-backend=os --chain-id \u0026#34;testnet-finney\u0026#34; --gas=\u0026#34;auto\u0026#34; --gas-adjustment=1.15 --fees 5000uhal NOTE: The value to be used instead of the \u0026lt;amount\u0026gt;stake can be calculated from the available balance. For example, if you\u0026rsquo;ve 999989990556 in the balance, you can stake 999909990556, note that the 5th digit, has been changed from 8 to 0 to leave some room for fees (amounts are multiplied by 10^6).\nAlso remember to replace halvaloper with your validator address and nym-admin with the user you created during initialization.\n"},{"uri":"https://nymtech.net/docs/use-apps/blockstream-green/","title":"Blockstream Green","tags":[],"description":"You can protect your Blockstream Green transactions from network eavesdroppers using the Nym mixnet. Here&#39;s how.","content":" You need to run the Nym Socks5 client before following the instructions on this page.\n Blockstream Green is a BitCoin and Liquid wallet. Since it supports Socks5, it can use Nym. Set your proxy settings in Green as follows.\nFirst you need to log out.\nNext, click on the settings on the right hand side to set proxy URL:\nMost wallets and other applications will work basically the same way: find the network proxy settings, enter the proxy url (host: localhost, port: 1080).\nIn some other applications, this might be written as localhost:1080 if there\u0026rsquo;s only one proxy entry field.\n"},{"uri":"https://nymtech.net/docs/use-apps/electrum/","title":"Electrum","tags":[],"description":"You can protect your Electrum transactions from network eavesdroppers using the Nym mixnet. Here&#39;s how.","content":" You need to run the Nym Socks5 client before following the instructions on this page.\n Here\u0026rsquo;s how you use Electrum with Nym\u0026rsquo;s Socks5 client:\nOnce you start using the nym-socks5-client, your wallet traffic will be sliced up into Sphinx packets, bounced and shuffled as wallet requests and responses pass through the Nym mixnet.\n"},{"uri":"https://nymtech.net/docs/use-apps/keybase/","title":"KeyBase","tags":[],"description":"You can protect your KeyBase chat traffic from network eavesdroppers using the Nym mixnet. Here&#39;s how.","content":"We have added support for KeyBase (which we use for our own internal chat). Feel free to try that out and say hello!\nThe socks5 settings in KeyBase are under Settings \u0026gt; Advanced \u0026gt; Proxy Settings.\n"},{"uri":"https://nymtech.net/docs/run-nym-nodes/requester/","title":"Requesters","tags":[],"description":"Run a requester proxy for the benefit of the community.","content":" The nym-network-requester was built in the building nym section. If you haven\u0026rsquo;t yet built Nym and want to run the code on this page, go there first.\n If you have access to a server, you can run the nym-network-requester, which allows Nym users to make outbound network requests from your server.\nThe nym-network-requester is NOT an open proxy. It ships with a file called allowed.list.sample, which contains URLs used by the Blockstream Green and Electrum cryptographic wallets.\nRunning nym-network-requester You can run the requester yourself, by taking the following steps.\nOn your server, build Nym. Then run the following commands from the top-level nym directory:\n target/release/nym-client init --gateway DiYR9o8KgeQ81woKPYVAu4LNaAEg8SWkiufDCahNnPov --id nym-network-requester-client target/release/nym-client run --id nym-network-requester-client target/release/nym-network-requester run  This will start up a Nym client, and the nym-network-requester requester will attach to it.\nMake a note of the address of the client when it starts up:\n 2020-09-10T14:45:50.131 INFO nym_client::client \u0026gt; The address of this client is: EzvzfN4baf3ULUbAmExQELUWMQry7qqVDibSyekR31KE.4khUuTUyYTWiLki3SKbxeG2sP3mwgn9ykBhvtyaLfMdN@DiYR9o8KgeQ81woKPYVAu4LNaAEg8SWkiufDCahNnPov Copy the whole address (format xxx.yyy@zzz) and keep it somewhere. You can use it yourself, give it to friends, or (if you would like to run a nym-network-requester for the whole Nym network) give it to us and we can put it in the Nym documentation.\nIs this safe to do? If it was an open proxy, this would be unsafe, because any Nym user could make network requests to any system on the internet.\nTo make things a bit less stressful for administrators, nym-network-requester drops all incoming requests by default. In order for it to make requests, you need to add specific domains to the allowed.list file at $HOME/.nym/service-providers/nym-network-requester/allowed.list.\nIf you want, you can just use the domains in the default allowed.list, by running this command from the top-level nym code directory:\ncp service-providers/nym-network-requester/allowed.list.sample ~/.nym/service-providers/nym-network-requester/allowed.list\nThose URLs will let through requests for the Blockstream Green and Electrum cryptocurrency wallets, as well as the KeyBase chat client.\nIMPORTANT: If you change your allowed.list, make sure you restart nym-network-requester to pick up the new allowed request list.\nAdding URLs for other clients It would suck if Nym was restricted to only three clients. How can we add support for a new application? It\u0026rsquo;s fairly easy to do.\nHave a look in your nym-network-requester config directory:\nls $HOME/.nym/service-providers/network-requester/ # returns: allowed.list unknown.list We already know that allowed.list is what lets requests go through. All unknown requests are logged to unknown.list. If you want to try using a new client type, just start the new application, point it at your local SOCKS5 proxy (configured to use your remote nym-network-requester), and keep copying URLs from unknown.list into allowed.list (it may take multiple tries until you get all of them, depending on the complexity of the application).\nIf you add support for a new application, we\u0026rsquo;d love to hear about it: let us know or submit a commented pull request on allowed.list.sample\nRunning an open proxy If you really, really want to run an open proxy, perhaps for testing purposes for your own use or among a small group of trusted friends, it is possible to do so. You can disable network checks by passing the flag --open-proxy flag when you run it. If you run in this configuration, you do so at your own risk.\n"},{"uri":"https://nymtech.net/docs/overview/private-access-control/","title":"Coconut","tags":[],"description":"Nym ensures access control privacy using a sophisticated signature scheme called Coconut.","content":"Introducing Coconut Coconut is a cryptographic signature scheme that produces privacy-enhanced credentials. It lets application programmers who are concerned with resource access control to think and code in a new way.\nMost of the time, when we build system security, we think of who questions:\n Has Alice identified herself (authentication)? Is Alice allowed to take a specific action (authorisation)?  Coconut fundamentally changes these questions. Rather than asking who a user is, it allows application designers to ask different questions, mostly centred around questions of rights:\n Does the entity taking this action have a right to do X?  This allows a different kind of security. Many of the computer systems we talk to every day don\u0026rsquo;t need to know who we are, they only need to know if we have a right to use the system. Coconut allows signing authorities and validators to work together to determine whether a given private key holder has a right to take an action. The credentials are generated cooperatively by decentralised, trustless systems.\nOnce the credentials are generated, they can be re-randomized: entirely new credentials, which no one has ever seen before, can be presented to service providers, and magically validated without being linkable back to the credential originally given out by validators.\nThese properties allow Coconut credentials to act as something like a decentralized and fully private version of OAuth credentials, or like cryptographic bearer tokens generated by decentralised systems. The tokens can be mutated so that they are not traceable, but still verified with the original permissions intact.\nUsers present cryptographic claims encoded inside the credentials to get secure access to resources despite the systems verifying credential usage not being able to know who they are.\nRe-randomisation vs pseudonymity We stand on the shoulders of giants. Ten years ago, Bitcoin showed the way forward by allowing people to control resource access without recourse to who questions. Rather, in Bitcoin and succeeding blockchains, a private key proves a right to use.\nBut as we can now see, private keys in blockchain systems act only as a minor barrier to finding out who is accessing resources. A Bitcoin or Ethereum private key is effectively a long-lived pseudonym which is easily traceable through successive transactions.\nCoconut allows us to build truly private systems rather than pseudonymous ones.\nHow does Coconut work? Just like normal credentials, Nym\u0026rsquo;s Coconut credentials can be signed with a secret key and later verified by anybody with the correct public key. But Nym credentials have additional superpowers when compared to \u0026ldquo;normal\u0026rdquo; signature schemes like RSA or DSA.\nSpecifically, Coconut is a blinded, re-randomizable, selective disclosure threshold credential signature scheme. That\u0026rsquo;s quite a mouthful, so let\u0026rsquo;s break it down into its component parts.\nLet\u0026rsquo;s say you have a message with the content This credential controls controls X in hand. In addition to the normal sign(message, secretKey) and verify(message, publicKey) functions present in other signature schemes, Coconut adds the following:\n  Blind signatures - disguises message content so that the signer can\u0026rsquo;t see what they\u0026rsquo;re signing. This defends users against signers: the entity that signed can\u0026rsquo;t identify the user who created a given credential, since they\u0026rsquo;ve never seen the message they\u0026rsquo;re signing before it\u0026rsquo;s been blinded (turned into gobbledygook). Coconut uses zero-knowledge proofs so that the signer can sign confidently without seeing the unblinded content of the message.\n  Re-randomizable signatures - take a signature, and generate a brand new signature that is valid for the same underlying message This credential controls X. The new bitstring in the re-randomized signature is equivalent to the original signature but not linkable to it. So a user can \u0026ldquo;show\u0026rdquo; a credential multiple times, and each time it appears to be a new credential, which is unlinkable to any previous \u0026ldquo;show\u0026rdquo;. But the underlying content of the re-randomized credential is the same (including for things like double-spend protection). This once again protects the user against the signer, because the signer can\u0026rsquo;t trace the signed message that they gave back to the user when it is presented. It also protects the user against the relying party that accepts the signed credential. The user can show re-randomized credentials repeatedly, and although the underlying message is the same in all cases, there\u0026rsquo;s no way of tracking them by watching the user present the same credential multiple times.\n  Selective disclosure of attributes - allows someone with the public key to verify some, but not all, parts of a message. So you could for instance selectively reveal parts of a signed message to some people, but not to others. This is a very powerful property of Coconut, potentially leading to diverse applications: voting systems, selective revelation of medical data, privacy-friendly KYC systems, etc.\n  Threshold issuance - allows signature generation to be split up across multiple nodes and decentralized, so that either all signers need to sign (n of n where n is the number of signers) or only a threshold number of signers need to sign a message (t of n where t is the threshold value).\n  Taken together, these properties provide privacy for applications when it comes to generating and using signatures for cryptographic claims. If you compare it to existing tech, you might think of it as a sort of supercharged decentralized privacy-friendly JWT.\nA slightly expanded view of Coconut is available in this blog post.\nUsing Coconut for blockchain transaction privacy In the context of a blockchain currency system, Coconut allows us to create a privacy-enhanced Coconut credential which provably represents an amount under control of a given entity. The credential can then be \u0026ldquo;spent\u0026rdquo; anonymously, as if it were the original value. Double-spending protections apply to the credential, so it can only be spent once. Nym Validators can then unlock the value so it can be redeemed by the party holding the credential.\nAlthough there\u0026rsquo;s still work to be done to integrate it against various blockchains, in principle Coconut can anonymise blockchain transactions in any system which provides multi-sig. We\u0026rsquo;re working on Cosmos integration at the moment. Bitcoin and Ethereum are also obvious targets here.\nCoconut is simple and flexible, and can ensure privacy for more than coin transfers; it can provide privacy for more complex smart contracts as well.\nFinally, it should be mentioned that Coconut can be applied to both blockchain and non-blockchain systems - it\u0026rsquo;s a general purpose technology.\n"},{"uri":"https://nymtech.net/docs/run-nym-nodes/gateways/","title":"Gateways","tags":[],"description":"Gateways provide a destination for mixnet packets. Most of the internet doesn&#39;t use encrypted Sphinx packets, so the gateway acts as a destination for Sphinx traffic.","content":"Gateways The Nym gateway was built in the building nym section. If you haven\u0026rsquo;t yet built Nym and want to run the code, go there first.\n Gateways provide a destination for mixnet packets. Most of the internet doesn\u0026rsquo;t use encrypted Sphinx packets, so the gateway acts as a destination, sort of like a mailbox, for messages.\nIf you would like to run a gateway for the network, please contact us.\nNym clients connect to gateways. Messages are automatically piped to connected clients and deleted from the gateway\u0026rsquo;s disk storage. If a client is offline when a message arrives, it will be stored for later retrieval. When the client connects, all messages will be delivered, and deleted from the gateway\u0026rsquo;s disk. As of release 0.8.x gateways use end-to-end encryption, so they cannot see the content of what they\u0026rsquo;re storing for users.\nWhen it starts up, a client registers itself with a gateway, and the gateway returns an access token. The access token plus the gateway\u0026rsquo;s IP can then be used as a form of addressing for delivering packets.\nThe default gateway implementation included in the Nym platform code holds packets for later retrieval. For many applications (such as simple chat), this is usable out of the box, as it provides a place that potentially offline clients can retrieve packets from. The access token allows clients to pull messages from the gateway node.\nYou can run the gateway like this:\nnym-gateway\nOutput looks like this:\n$ ./nym-gateway _ __ _ _ _ __ ___ | \u0026#39;_ \\| | | | \u0026#39;_ \\ _ \\  | | | | |_| | | | | | | |_| |_|\\__, |_| |_| |_| |___/ (gateway - version 0.10.0) usage: --help to see available options. ./nym-gateway init --help shows available configuration options\nInitializing a gateway The init command sets up the gateway. You must supply 3 parameters:\n --id a name for this gateway (determines where the config file will be saved, keep it to one word) --clients-host needs to be an IPv4 or IPv6 address. This is the IP that the gateway will listen on for requests coming from Nym clients. --mix-host needs to be an IPv4 or IPv6 address. This is the IP that the gateway will listen on for incoming Sphinx packets coming from the mixnet.  Example:\n./nym-gateway init --clients-host 82.32.45.6 --mix-host 82.32.45.6 --id supergateway starts up a gateway node with default options, running on 82.32.45.6. Note that you need to use an internet-addressable host ip. Gateways must also be capable of addressing IPv6.\nRunning a gateway The run command runs the gateway.\nExample:\n./nym-gateway run --id supergateway\nResults in:\n _ __ _ _ _ __ ___ | '_ \\| | | | '_ \\ _ \\ | | | | |_| | | | | | | |_| |_|\\__, |_| |_| |_| |___/ (gateway - version 0.10.0) Starting gateway supergateway... Public key: DFvUKggcDZcqKqemK8C1KXNmBvJasp1A3ZRFdETVV9eX Directory server [presence]: https://testnet-validator1.nymtech.net Listening for incoming sphinx packets on 127.0.0.1:1789 Announcing the following socket address for sphinx packets: 127.0.0.1:1789 Listening for incoming clients packets on 127.0.0.1:9000 Announcing the following socket address for clients packets: ws://127.0.0.1:9000 Inboxes directory is: \u0026quot;~/.nym/gateways/supergateway/data/inboxes\u0026quot; Clients ledger is stored at: \u0026quot;~/.nym/gateways/supergateway/data/client_ledger.sled\u0026quot; 2020-05-26T18:40:18.713 INFO nym_gateway::node \u0026gt; Starting nym gateway! 2020-05-26T18:40:19.071 INFO nym_gateway::node \u0026gt; Starting mix packet forwarder... 2020-05-26T18:40:19.071 INFO nym_gateway::node \u0026gt; Starting clients handler 2020-05-26T18:40:19.071 INFO nym_gateway::node \u0026gt; Starting mix socket listener... 2020-05-26T18:40:19.071 INFO nym_gateway::node \u0026gt; Starting client [web]socket listener... 2020-05-26T18:40:19.072 INFO nym_gateway::node \u0026gt; Starting presence notifier... 2020-05-26T18:40:19.072 INFO nym_gateway::node::mixnet_handling::receiver::listener \u0026gt; Starting mixnet listener at 127.0.0.1:1789 2020-05-26T18:40:19.072 INFO nym_gateway::node::client_handling::websocket::listener \u0026gt; Starting websocket listener at 127.0.0.1:9000 2020-05-26T18:40:19.081 INFO nym_gateway::node \u0026gt; Finished nym gateway startup procedure - it should now be able to receive mix and client traffic! We are currently running only one gateway, and it\u0026rsquo;s going to become a bottleneck in the network. If you are interested in running a gateway for the network, please let us know.\n"},{"uri":"https://nymtech.net/docs/overview/links/","title":"Links","tags":[],"description":"Here are some links that may prove handy as you start exploring Nym, and the Nym community.","content":"Here are some links that may prove handy as you start exploring.\nThe Nym Project  You can chat to us in Keybase. Download the app, then click Teams -\u0026gt; Join a team. Type nymtech.friends into the team name and hit continue. For general chat, hang out in the #general channel. Our development takes places in the #dev channel. Node operators should be in the #node-operators channel to receive notice of system updates or node downtime. The Nym website has general info on project status and links to learning materials and talks we\u0026rsquo;ve given The Nym blog provides up to date project news and views The Nym docs tell you how to build and use the Nym platform The Nym Platform code repo contains most parts of the Nym system in one convenient place The Nym Validator repo contains our Cosmos-based validator code The Nym Explorer shows testnet nodes and activity Community member HansBricks has contributed a Docker image for running mixnodes.  Academic Papers  Coconut Sphinx (pdf) Loopix  "},{"uri":"https://nymtech.net/docs/build-apps/websocket-client/","title":"Websocket client","tags":[],"description":"How to run the Nym websocket client on a desktop or server machine.","content":" The Nym Websocket Client was built in the building nym section. If you haven\u0026rsquo;t yet built Nym and want to run the code on this page, go there first.\n From inside the nym directory, the nym-client binary got built to the ./target/release/ directory. You can run it like this (or add it to your $PATH):\n./nym-client\n$ ./nym-client _ __ _ _ _ __ ___ | \u0026#39;_ \\| | | | \u0026#39;_ \\ _ \\  | | | | |_| | | | | | | |_| |_|\\__, |_| |_| |_| |___/ (client - version 0.10.0) usage: --help to see available options. There are two commands you can issue to the client.\n init - initialize a new client instance. Requires --id clientname parameter. run - run a mixnet client process. Requires --id clientname as a parameter  Initializing a new client instance Before you can use the client, you need to initialize a new instance of it. Each instance of the client has its own public/private keypair, and connects to its own gateway node. Taken together, these 3 things (public/private keypair + gateway node) make up an app\u0026rsquo;s identity.\nInitializing a new client instance can be done with the following command:\n./nym-client init --id alice When you initialize a client instance, a configuration directory will be generated and stored in $HOME_DIR/.nym/clients/\u0026lt;client-name\u0026gt;/.\n$ tree ~/.nym/clients/alice/ /home/dave/.nym/clients/alice/ ├── config │ └── config.toml └── data ├── private_identity.pem └── public_identity.pem The file config.toml contains client configuration options, while the two pem files contain client key information.\nHave a look at the generated files if you\u0026rsquo;d like - they contain the client name, public/private keypairs, and gateway address. The name alice in the example above is just a local identifier so that you can name your clients; it is never transmitted over the network.\nRunning the native client You can run the alice client by doing this:\n./nym-client run --id alice When you run the client, it immediately starts generating (fake) cover traffic and sending it to the Nym testnet.\nCongratulations, you have just contributed a tiny bit of privacy to the world! \u0026lt;CTRL-C\u0026gt; to stop the client.\n When the client is first started, it will reach out to the Nym network\u0026rsquo;s validators, and get a list of available Nym nodes (gateways, mixnodes, and validators). We call this list of nodes the network topology. The client does this so that it knows how to connect, register itself with the network, and know which mixnodes it can route Sphinx packets through.\nOnce the client has obtained the network topology, it automatically sends a registration request to one of the first available gateway. The gateway returns a unique authentication token that the client attaches to every subsequent request to the gateway.\nConnecting to the local websocket The Nym native client exposes a websocket interface that your code connects to. To program your app, choose a websocket library for whatever language you\u0026rsquo;re using. The default websocket port is 1977, you can override that in the client config if you want.\nA simple example peap Let\u0026rsquo;s write some code. Sometimes when you\u0026rsquo;re learning something new it\u0026rsquo;s easiest to see a short working example. Here\u0026rsquo;s a simple app written in Python. This example is packaged with the Nym platform, dig around in the python-examples directory inside clients/native\nimport asyncio import json import websockets self_address_request = json.dumps({ \u0026#34;type\u0026#34;: \u0026#34;selfAddress\u0026#34; }) async def send_text(): message = \u0026#34;Hello Nym!\u0026#34; uri = \u0026#34;ws://localhost:1977\u0026#34; async with websockets.connect(uri) as websocket: # 1 await websocket.send(self_address_request) self_address = json.loads(await websocket.recv()) print(\u0026#34;our address is: {}\u0026#34;.format(self_address[\u0026#34;address\u0026#34;])) text_send = json.dumps({ # 2  \u0026#34;type\u0026#34;: \u0026#34;send\u0026#34;, \u0026#34;message\u0026#34;: message, \u0026#34;recipient\u0026#34;: self_address[\u0026#34;address\u0026#34;] }) print(\u0026#34;sending \u0026#39;{}\u0026#39; over the mix network...\u0026#34;.format(message)) await websocket.send(text_send) # 3 msg_send_confirmation = json.loads(await websocket.recv()) # 4 assert msg_send_confirmation[\u0026#34;type\u0026#34;], \u0026#34;send\u0026#34; print(\u0026#34;waiting to receive a message from the mix network...\u0026#34;) received_message = await websocket.recv() # 5 print(\u0026#34;received {} from the mix network!\u0026#34;.format(received_message)) asyncio.get_event_loop().run_until_complete(send_text()) The Python code does the following.\n connects to the websocket on port 1977 formats a message to send. Nym messages have defined JSON formats. sends the message into the websocket. The native client packages the message into a Sphinx packet and sends it to the mixnet waits for confirmation that the message hit the native client waits to receive messages from other Nym apps  By varying the message content, you can easily build sophisticated Service Provider apps. For example, instead of print(\u0026quot;received {} from the mix network!\u0026quot;.format(received_message)) your Service Provider might take some action on behalf of the user - perhaps initiating a network request, a blockchain transaction, or writing to a local data store.\nMessage Types There are a small number of messages that your application sends up the websocket to interact with the native client, as follows.\nSending text If you want to send text information through the mixnet, format a message like this one and poke it into the websocket:\n{ \u0026#34;type\u0026#34;: \u0026#34;send\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;the message\u0026#34;, \u0026#34;recipient_address\u0026#34;: \u0026#34;71od3ZAupdCdxeFNg8sdonqfZTnZZy1E86WYKEjxD4kj@FWYoUrnKuXryysptnCZgUYRTauHq4FnEFu2QGn5LZWbm\u0026#34; } In some applications, e.g. where people are chatting with friends who they know, you might want to include unencrypted reply information in the message field, like so:\n{ \u0026#34;type\u0026#34;: \u0026#34;send\u0026#34;, \u0026#34;message\u0026#34;: { \u0026#34;sender\u0026#34;: \u0026#34;198427b63ZAupdCdxeFNg8sdonqfZTnZZy1E86WYKEjxD4kj@FWYoUrnKuXryysptnCZgUYRTauHq4FnEFu2QGn5LZWbm\u0026#34;, \u0026#34;chatMessage\u0026#34;: \u0026#34;hi julia!\u0026#34; }, \u0026#34;recipient_address\u0026#34;: \u0026#34;71od3ZAupdCdxeFNg8sdonqfZTnZZy1E86WYKEjxD4kj@FWYoUrnKuXryysptnCZgUYRTauHq4FnEFu2QGn5LZWbm\u0026#34; } This provides an easy way for the receiving chat to then turn around and send a reply message:\n{ \u0026#34;type\u0026#34;: \u0026#34;send\u0026#34;, \u0026#34;message\u0026#34;: { \u0026#34;sender\u0026#34;: \u0026#34;71od3ZAupdCdxeFNg8sdonqfZTnZZy1E86WYKEjxD4kj@FWYoUrnKuXryysptnCZgUYRTauHq4FnEFu2QGn5LZWbm\u0026#34;, \u0026#34;chatMessage\u0026#34;: \u0026#34;winston, so lovely to hear from you! shall we meet at the antiques shop?\u0026#34; }, \u0026#34;recipient_address\u0026#34;: \u0026#34;198427b63ZAupdCdxeFNg8sdonqfZTnZZy1E86WYKEjxD4kj@FWYoUrnKuXryysptnCZgUYRTauHq4FnEFu2QGn5LZWbm\u0026#34; } If that fits your security model, good. However, it may be the case that you want to send anonymous replies using Single Use Reply Blocks, or surbs. These will be available in the next version of Nym (0.11.0).\nSending binary data You can also send bytes instead of JSON. A Python program to send a file dummy_file looks like this:\nasync def send_file(): uri = \u0026#34;ws://localhost:1977\u0026#34; async with websockets.connect(uri) as websocket: await websocket.send(self_address_request) self_address = json.loads(await websocket.recv()) print(\u0026#34;our address is: {}\u0026#34;.format(self_address[\u0026#34;address\u0026#34;])) # We receive our address in string format of  # OUR_PUB_KEY @ OUR_GATE_PUB_KEY # # Both keys are 32 bytes and we need to encode them as binary  # without the \u0026#39;@\u0026#39; sign split_address = self_address[\u0026#34;address\u0026#34;].split(\u0026#34;@\u0026#34;) bin_payload = bytearray(base58.b58decode(split_address[0])) bin_payload += base58.b58decode(split_address[1]) with open(\u0026#34;dummy_file\u0026#34;, \u0026#34;rb\u0026#34;) as input_file: read_data = input_file.read() bin_payload += read_data print(\u0026#34;sending content of \u0026#39;dummy_file\u0026#39; over the mix network...\u0026#34;) await websocket.send(bin_payload) msg_send_confirmation = json.loads(await websocket.recv()) assert msg_send_confirmation[\u0026#34;type\u0026#34;], \u0026#34;send\u0026#34; print(\u0026#34;waiting to receive the \u0026#39;dummy_file\u0026#39; from the mix network...\u0026#34;) received_data = await websocket.recv() with open(\u0026#34;received_file\u0026#34;, \u0026#34;wb\u0026#34;) as output_file: print(\u0026#34;writing the file back to the disk!\u0026#34;) output_file.write(received_data) asyncio.get_event_loop().run_until_complete(send_file()) In order to send binary messages, you format a 64-byte binary array, with the first 32 bytes being the recipient pubkey, and the second 32 bytes being the destination gateway pubkey. The remainder of the payload is the bytes of the binary data you\u0026rsquo;d like to send.\nReceiving messages When another peap sends a message to you, all extraneous information is stripped and you just get the message. So if an app sends the following message:\n{ \u0026#34;type\u0026#34;: \u0026#34;send\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;2 + 2 = 4\u0026#34;, \u0026#34;recipient_address\u0026#34;: \u0026#34;71od3ZAupdCdxeFNg8sdonqfZTnZZy1E86WYKEjxD4kj@FWYoUrnKuXryysptnCZgUYRTauHq4FnEFu2QGn5LZWbm\u0026#34; } The receiving user will get only 2 + 2 = 4.\nGetting your own address Sometimes, when you start your app, it can be convenient to ask the native client to tell you what your own address is (from the saved configuration files). To do this, send:\n{ \u0026#34;type\u0026#34;: \u0026#34;selfAddress\u0026#34; } You\u0026rsquo;ll get back:\n{ \u0026#34;type\u0026#34;: \u0026#34;selfAddress\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;the-address\u0026#34; } Error messages Errors from the app\u0026rsquo;s client, or from the gateway, will be sent down the websocket to your code in the following format:\n{ \u0026#34;type\u0026#34;: \u0026#34;error\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;string message\u0026#34; } "},{"uri":"https://nymtech.net/docs/run-nym-nodes/troubleshooting/","title":"Mixnode Troubleshooting FAQ","tags":[],"description":"This page will help you find answers to common issues with setting up and maintaining mixnodes","content":" How can I tell my node is up and running and mixing traffic?  To check from the machine your node is running on: To double check from your local machine   Why is my node not mixing any packets \u0026amp; Setting up the firewall How can I make sure my node works from my local machine if I\u0026rsquo;m behind NAT and have no fixed IP address ? Can I use a different port other than 1789 ?  Configuring the firewall Edit existing config   Where can I find my private and public keys and mixnode config? I keep seeing ERROR or WARN messages in my node logs. Why is that ? I compiled Nym from source. How do I make the mixnode run in the background? Where can I get more help?    How can I tell my node is up and running and mixing traffic? First of all check the testnet dashboard. Go to Mixnodes and search for your node.\nAdditional details can be obtained after you connect to your server.\nHere are some examples on how to check if the node is configured properly.\nTo check from the machine your node is running on:  sudo ss -s -t | grep 1789 This should work on every unix based system sudo lsof -i TCP:1789 if you get command not found, do sudo apt install lsof sudo journalctl -u nym-mixnode -o cat | grep \u0026quot;Since startup mixed\u0026quot;  If you created nym-mixnode.service file then this command shows you how many packets have you mixed so far. you can add  | tail after the command to watch it in real time if needed.  To double check from your local machine  telnet \u0026lt;IP ADDRESS\u0026gt; 1789\u0026lt;OR OTHER PORT\u0026gt; nmap -p 1789 \u0026lt;IP ADDRESS\u0026gt; -Pn  This won\u0026rsquo;t tell you much but as long as your telnet connetion does not hang on \u0026ldquo;Trying \u0026hellip;\u0026rdquo; it should mean your mixnode is accessible from the outside.\nThis is how an output from above nmap command should look like if your mixnode is configured properly :\nbob@desktop:~$ nmap -p 1789 95.296.134.220 -Pn Host is up (0.053s latency). PORT STATE SERVICE 1789/tcp open hello You can query all mixnodes as well, and further parse it with a little help of jq\n curl https://testnet-finney-explorer.nymtech.net/data/mixnodes.json | jq  you can parse it further then\nfor instance - get a list of nodes with location in London\n curl https://testnet-finney-explorer.nymtech.net/data/mixnodes.json | jq -r '.[].mix_node | select(.location == \u0026quot;London\u0026quot;)'  or to see all nodes starting with ipv4 address 65.21.x.x and list only their complete ipv4 addresses\n curl https://testnet-finney-explorer.nymtech.net/data/mixnodes.json | jq -r '.[].mix_node | select(.host | startswith(\u0026quot;65.21\u0026quot;)) | .host'   Why is my node not mixing any packets \u0026amp; Setting up the firewall If you are unable to see your node on the dashboard or with other above mentioned ways to check up on your node then it is usually quite simple and straightforward to solve this issue. The most probable reason being :\n Firewall on your host machine is not configured. You used incorrect details during the bonding process of your node from the web wallet Not using \u0026ndash;anounce-host flag while running mixnode from your local machine behind NAT. You did not configure your router firewall while running the mixnode from your local machine behind NAT or you are lacking IPv6 support. Your mixnode must speak both IPv4 and IPv6. You will need to cooperate with other nodes in order to route traffic. Mixnode is not running at all, it either exited or you closed the session without making the node persistent.  Check your firewall settings on your host machine. Easiest way on your VPS is to use ufw On some systems, like Debian 10 server, ufw is not installed by default\n as a root user on Debian 10 install ufw - apt install ufw -y  On Ubuntu, first check if your ufw is enabled - ufw status  ufw allow 1789/tcp \u0026amp;\u0026amp; ufw allow 22/tcp \u0026amp;\u0026amp; ufw enable - \u0026gt; This will allow port 1789 for the mixnode, 22 for ssh and then enables the firewall. Your node should work right after that. Note: You need to add sudo  before each ufw  command if you\u0026rsquo;re not a root user. sudo ufw allow 1789/tcp . The \u0026amp;\u0026amp; symbols are used to chain together commands in Linux.  On certain cloud providers such as AWS and Google Cloud, you need to do some additional configuration of your firewall and use --host with your local ip and --announce-host with the public ip of your mixnode host.\nTo get all ip addresses of your host, try following:\nhostname -i shows you your local ip address, hostname -I which will show you all ip addresses of your host. Here is an example output.\nbob@nym:~$ hostname -I 88.36.11.23 172.18.0.1 2a01:28:ca:102::1:641  The first ipv4 is your public ip you need to use for --anounce-host The second ipv4 is your local ip that you have to use for --host And the 3rd one should confirm if your machine has ipv6 available.  How can I make sure my node works from my local machine if I\u0026rsquo;m behind NAT and have no fixed IP address ? First of all, your ISP has to be IPv6 ready. Sadly, in 2020, most of them are not and you won\u0026rsquo;t get an IPv6 address by default from your ISP. Usually it is a extra paid service or they simply don\u0026rsquo;t offer it.\nBefore you begin, check if you have IPv6 here. If not, then don\u0026rsquo;t waste your time to run a node which won\u0026rsquo;t ever be able to mix any packet due to this limitation. Call your ISP and ask for IPv6, there is a plenty of it for everyone!\nIf all goes well and you have IPv6 available, then you will need to init the mixnode with an extra flag, --announce-host. You will also need to edit your config file each time your IPv4 address changes, that could be a few days or a few weeks.\nAdditional configuration on your router might also be needed to allow traffic in and out to port 1789 and IPv6 support.\nHere is a sample of the init command to create the mixnode config.\n./target/release/nym-mixnode init --id nym-nat --host 0.0.0.0 --announce-host 85.160.12.13 --layer 3 --location Mars  --host 0.0.0.0 should work everytime even if your local machine IPv4 address changes. For example on Monday your router gives your machine an address 192.168.0.13 and on Wednesday, the DHCP lease will end and you will be asigned 192.168.0.14. Using 0.0.0.0 should avoid this without having to set any static ip in your router`s configuration. you can get your current IPv4 address by either using curl ipinfo.io if you\u0026rsquo;re on MacOS or Linux or visiting whatsmyip site. Simply copy it and use it as --anounce-host address.  Make sure you check if your node is really mixing. You will need a bit of luck to set this up from your home behind NAT.\nCan I use a different port other than 1789 ? Yes! Here is what you will need. Let\u0026rsquo;s say you would like to use port 1337 for your mixnode.\nConfiguring the firewall sudo ufw allow 1337 (run without sudo if you are root). More details about this can be found in the Why is my node not mixing any packets \u0026amp; Setting up the firewall section of this wiki.\nEdit existing config If you already have a config you created before and want to change the port, you need to stop your node if it\u0026rsquo;s running and then edit your config file. Assuming your node name is nym, the config file is located at ~/.nym/mixnodes/nym/config/config.toml.\nnano ~/.nym/mixnodes/nym/config/config.toml You will need to edit two parts of the file. announce_address and listening_address in the config.toml file. Simply find these two parts, delete your former port :1789 and append :1337 after your IP address.\nTo save the edit, press CTRL+O and then exit CTRL+X. Then run the node again. You should see if the mixnode is using the port you have changed in the config.toml file right after you run the node.\nWhere can I find my private and public keys and mixnode config? All config and keys files are stored in a directory named after your id which you chose during the init configuration with a following PATH: $HOME/.nym/mixnodes/ where $HOME is a home directory of the user (your current user in this case) that launched the mixnode.\nDepending on how you installed Nym, the files will be stored here:\n Autoinstaller - /home/nym/.nym/mixnodes/\u0026lt;YOURNODEID\u0026gt; Built from source as your user or root - ~/.nym/mixnodes/\u0026lt;YOURNODEID\u0026gt;  The directory structure looks as following:\nbob@nym:~$ tree /home/nym/.nym/mixnodes/ /home/nym/.nym/mixnodes/ |-- nym010 | |-- config | | `-- config.toml | `-- data | |-- private_identity.pem | |-- private_sphinx.pem | |-- public_identity.pem | `-- public_sphinx.pem Note: If you cat the public_sphinx.pem key, the output will be different from the public key you will see on Nym dashboard. Reason being .pem files are encoded in base64, however; on web they are in different encoding - base58. Don\u0026rsquo;t be confused if your keys look different. They are the same keys, just with different encoding :).\nI keep seeing ERROR or WARN messages in my node logs. Why is that ? I have seen quite a few errors from community members in our Telegram help chat.\nMost of them are benign. Usually you will encounter errors when your nodes tries to estabilish a connection with a \u0026ldquo;dead\u0026rdquo; node, that is misconfigured(most likely its firewall is).\nAs long as your node outputs since startup mixed 1337 packets! in your logs, you should be fine. If you want to be sure, check the Nym dashboard or see other ways on how to check if your node is really mixing, mentioned in section How can I tell my node is up and running and mixing traffic? in this wiki.\nI compiled Nym from source. How do I make the mixnode run in the background? When you close current session, you kill the process and therefore the mixnode will stop. There are multiple ways on how to make it persistent even after exiting your ssh session. Tmux, screen for instance.\nEasy solution would be to use nohup -\u0026gt; nohup`./nym-mixnode run --id NYM \u0026amp;  where --id NYM is the id you set during the init command previously.\nHowever, the most reliable and elegant solution is to create a systemd.service file and run the nym-mixnode with systemctl command.\nCreate a file with nano and copy there following. IMPORTANT: You need to write there your node id which you set up in the config earlier, else it won\u0026rsquo;t work! At line ExecStart, rewrite the \u0026ndash;id SOMENAME with exactly the same name as you used for the config.\nsudo nano /etc/systemd/system/nym-mixnode.service\nCopy there this and change the id name and path depending on the way how you installed your mixnode\n[Unit] Description=nym mixnode service After=network.target [Service] Type=simple User=nym LimitNOFILE=65536 ExecStart=/home/nym/nym-mixnode run --id nym KillSignal=SIGINT Restart=on-failure RestartSec=30 Restart=on-abort [Install] WantedBy=multi-user.target Now pres CTRL + O to write the file, hit enter. Then exit with CTRL + W.\nsudo systemctl enable nym-mixnode \n Enable the service  sudo systemctl start nym-mixnode \n Start the service  sudo systemctl status nym-mixnode \n Check if the service is running properly and mixnode is mixing.  Now your node should be mixing all the time unless you restart the server!\nAnytime you change your systemd service file you need to sudo systemctl daemon-reload and restart the service.\nWhere can I get more help? The fastest way to reach one of us or get a help from the community, visit our Telegram help chat.\nFor more tech heavy questions join our Keybase channel. Get Keybase here, then click Teams -\u0026gt; Join a team. Type nymtech.friends into the team name and hit continue. For general chat, hang out in the #general channel. Our development takes places in the #dev channel.\n"},{"uri":"https://nymtech.net/docs/build-apps/wasm-client/","title":"Webassembly client","tags":[],"description":"How to integrate the Nym webassembly client into your own applications to enable strong privacy for your users","content":"The Nym webassembly client allows any webassembly-capable runtime to build and send Sphinx packets to the Nym network.\nYou can install @nymproject/nym-client-wasm from NPM from its package page, or\nnpm i @nymproject/nym-client-wasm The nym-client-wasm package allows easy creation of Sphinx packets from within mobile apps and browser-based client-side apps (including Electron or similar). Browser extensions should also work.\nThe webassembly client lets you deliver web apps that build and send Sphinx packets solely in a web browser window. However, note that all the normal constraints of browser-based key storage and same-origin rules (which are there for good reason) make it difficult to structure pure webapps apps securely. We are still assessing what can be done here.\nBuilding apps with nym-client-wasm There are two example applications located in the directory clients/webassembly in the main Nym platform codebase. The js-example is a simple, bare-bones JavaScript app. The react-example is a nicer-looking chat app done in React and Typescript.\nInitializing a new Nym identity The main methods you\u0026rsquo;ll use from the NPM package are:\nlet identity = new Identity(); This generates a new Nym identity, consisting of a public/private keypair and a Nym gateway address.\nConstructing a Nym client let client = new Client(directoryUrl, identity, authToken); This returns a nym Client which connects to a Nym gateway via websocket. All communication with the Nym network happens through this client.\nThe directoryUrl of the Nym testnet is http://testnet-validator1.nymtech.net:8081. Use that if you want to connect to the running testnet.\nRunning the Nym client client.start(); This will cause the client to retrieve a network topology from the defined directoryUrl, and connect to its gateway via websocket. Cover traffic is not yet sent, but message sends should work after client start.\nSending messages client.sendMessage(message, recipient) { Sends a message up the websocket to this client\u0026rsquo;s Nym gateway.\nNOTE: the webassembly client currently does not implement chunking. Messages over ~1KB will cause a panic. This will be fixed in a future version.\nmessage must be a string at the moment. Binary Blob and ArrayBuffer will be supported soon.\nrecipient is a Nym address as a string.\nGetting the client\u0026rsquo;s address Given a client, to get its address, you can call:\nclient.formatAsRecipient(); SURBs Anonymous replies using surbs don\u0026rsquo;t yet work in the webassembly client. They should be available in the next release (0.11.0).\nJSON Sending JSON is fairly simple. If you\u0026rsquo;re playing with the wasm example app, just stick it into the message box and send it (or send it programmatically as the message content of client.sendMessage(message, recipient) in your own application code.\nThink about what you\u0026rsquo;re sending! Think about what information your app sends. That goes for whatever you put into your Sphinx packet messages as well as what your app\u0026rsquo;s environment may leak.\n Whenever you write client peaps using HTML/JavaScript, we recommend that you do not load external resources from CDNs. Webapp developers do this all the time, to save load time for common resources, or just for convenience. But when you\u0026rsquo;re writing privacy apps it\u0026rsquo;s better not to make these kinds of requests. Pack everything locally.\nIf you use only local resources within your Electron app or your browser extensions, explicitly encoding request data in a Sphinx packet does protect you from the normal leakage that gets sent in a browser HTTP request. There\u0026rsquo;s a lot of stuff that leaks when you make an HTTP request from a browser window. Luckily, all that metadata and request leakage doesn\u0026rsquo;t happen in Nym, because you\u0026rsquo;re choosing very explicitly what to encode into Sphinx packets, instead of sending a whole browser environment by default.\n"},{"uri":"https://nymtech.net/docs/build-apps/demos/","title":"Demos","tags":[],"description":"Example code for interacting with the Nym privacy network, in multiple languages.","content":"We have included code examples for multiple languages inside the clients/native/examples directory within our codebase - you can see how to connect and send messages from Go, Python, Rust, and JavaScript there.\nIt may also be worth running the webassembly example code in clients/webassembly/js-example if you\u0026rsquo;re planning to run your using browser or other js technology.\n"},{"uri":"https://nymtech.net/docs/use-apps/","title":"Use Apps","tags":[],"description":"Tutorials for building Privacy Enhanced Applications (or integrating existing apps with Nym)","content":" The Nym SOCKS5 Client was built in the building nym section. If you haven\u0026rsquo;t yet built Nym and want to run the code on this page, go there first.\n Nym is a general purpose system. We aim to provide the strongest possible protections for internet traffic and transactions.\nThe system is still very young, but it\u0026rsquo;s starting to be able to do useful work. You can start using it today.\nMany existing applications are able to use the SOCKS5 proxy protocol. They can use the nym-socks5-client to bounce their network traffic through the Nym network, like this:\nThe Nym network already runs the mixnet, and the nym-network-requester / nym-client parts. In order to use existing applications with Nym, you only need to set up the nym-socks5-client.\nNote that the nym-network-requester we\u0026rsquo;re running works only for specific applications. We are not running an open proxy, we have an allowed list of applications that can use the mixnet (currently Blockstream Green, Electrum, and KeyBase). We can add other applications upon request, just come talk to us in our dev chat. Or, you can set up your own nym-network-requester, it\u0026rsquo;s not very hard to do if you have access to a server.\nRunning the nym-socks5-client Obligatory disclaimer time: The Nym mixnet is still under construction and has not undergone a security audit. Do not rely on it for strong privacy (yet).\n After building the Nym platform code, initialize nym-socks5-client:\nnym-socks5-client init --id my-socks5-client --provider Ei49VdLRx2d49Zhweqj77SGidhWoiU8nRtChXXd8NUor.AaoJyib37gG54GVaESivpCT2A35AQ3wQDh8WW7y3EYMn@AmoRv85ak8UrYkqd43NZpQJFQjn8rtgMfViBgAFaPDRh\nThe --provider field needs to be filled with the Nym address of a nym-network-requester that can make network requests on your behalf. The one above is the initial Nym one, but you can run your own if you want.\nThen run the socks5 client locally:\nnym-socks5-client run --id my-socks5-client\nThis will start up a SOCKS5 proxy on your local machine, at localhost:1080.\nIn the next few sections, we will show you how to run it with some existing applications. Later, we will discuss how you can use any application that can use SOCKS5 with Nym.\n"},{"uri":"https://nymtech.net/docs/build-apps/","title":"Build Apps","tags":[],"description":"Tutorials for building Privacy Enhanced Applications (or integrating existing apps with Nym)","content":"If you are a coder, we invite you to build privacy enhanced applications using Nym.\nNym lets you build privacy respecting clients and services which use our network infrastructure. Your apps can then connect to other apps also using the Nym network. All app-to-app communication happens over a set of cooperating networked nodes called a mixnet.\nMixnets give strong privacy guarantees against third-party observers.\nIt is apparent to any external network adversary that a given machine has connected to Nym infrastructure. Beyond that, it should not be possible to infer what activity is taking place unless there are observable network side effects (i.e. a Service Provider that makes network requests on behalf of a Nym client).\nWe\u0026rsquo;ll get into the technical details more deeply in the next few sections, but before we do that, let\u0026rsquo;s take a look at the steps involved in building and using a simple application.\nInitialization First, we need to initialize an app and connect it to Nym.\nAt the bottom we have an app. It consists of two parts:\n your application specific logic (which you write in whatever language makes sense: Python, Go, C#, Java, JavaScript, Haskell, etc) in yellow Nym client code in blue  Nym apps have a stable, potentially long-lasting relation to a Nym node type known as a gateway. An app registers itself with a gateway, and gets back an authentication token that it can then use to retrieve messages from the gateway.\nGateways serve a few different functions:\n they act as an end-to-end encrypted message store in case your app goes offline. they send encrypted surb-acks for potentially offline recipients, to ensure reliable message delivery they offer a stable addressing location for apps, although the IP may change frequently  Nym addresses When the app is initialized, it generates and stores its own public/private keypair locally. When the app starts, it automatically connects to the Nym network and finds out what Nym infrastructure exists. It then chooses and connects to a Nym gateway node via websocket.\nAll apps in the Nym network therefore have an address, in the format user-identity-key.user-encryption-key@gateway-identity-key. Clients print out their address at startup.\nOur app knows its own address, because it knows its own public key and the address of its gateway.\nSending messages to ourself The nym client part of the app (in blue) accepts messages from your code (in yellow), and automatically turns it into layer-encrypted Sphinx packets. If your message is too big to fit inside on Sphinx packet, it\u0026rsquo;ll be split into multiple packets with a sequence numbers to ensure reliable automatic reassembly of the full message when it gets to the recipient.\nThe app has now connected to the gateway, but we haven\u0026rsquo;t sent a message to ourselves yet. Let\u0026rsquo;s do that now.\nLet\u0026rsquo;s say your code code pokes a message hello world into the nym client. The nym client automatically wraps that message up into a layer encrypted Sphinx packet, adds some routing information and encryption, and sends it to its own gateway. The gateway strips the first layer of encryption, ending up with the address of the first mixnode it should forward to, and a Sphinx packet.\nThe gateway forwards the Sphinx packet containing the hello world message. Each mixnode in turn forwards to the next mixnode. The last mixnode forwards to the recipient gateway (in this case, our own gateway since we are sending to ourself).\nOur app has presumably not gone offline in the short time since the message was sent. So when the gateway receives the packet, it decrypts the packet and sends the (encrypted) content back to our app.\nThe nym client inside the app decrypts the message, and your code receives the message hello world, again as a websocket event.\nMessages are end-to-end encrypted. Although the gateway knows our app\u0026rsquo;s IP when it connects, it\u0026rsquo;s unable to read any of the message contents.\nSending messages to other apps The process for sending messages to other apps is exactly the same, you simply specify a different recipient address. Address discovery happens outside the Nym system: in the case of a Service Provider app, the service provider has presumably advertised its own address. If you\u0026rsquo;re sending to a friend of yours, you\u0026rsquo;ll need to get ahold of their address out of band, maybe through a private messaging app such as Signal.\nClients vs Service Providers We expect that apps will typically fall into one of two broad categories:\n client apps Service Providers  Client apps expose a UI for users to interact with Nym. Typically they\u0026rsquo;ll run on user devices, such as laptops, phones, or tablets.\nService Providers, on the other hand, will generally run on server machines. Most Service Providers will run 24/7 and take action on behalf of anonymous client apps connected to the mixnet.\nPrivate Replies using surbs Surbs allow apps to reply to other apps anonymously.\nIt will often be the case that a client app wants to interact with a Service Provider app. It sort of defeats the purpose of the whole system if your client app needs to reveal its own gateway public key and client public key in order to get a response from the Service Provider.\nLuckily, there are Single Use Reply Blocks, or surbs.\nA surb is a layer encrypted set of Sphinx headers detailing a reply path ending in the original app\u0026rsquo;s address. Surbs are encrypted by the client, so the Service Provider can attach its response and send back the resulting Sphinx packet, but it never has sight of who it is replying to.\nOffline / Online Apps If a message arrives at a gateway address but the app is offline, the gateway will store the messages for later delivery. When the recipient app comes online again, it will automatically download all the messages, and they\u0026rsquo;ll be deleted from the gateway disk.\nIf an app is online when a message arrives for it, the message is automatically pushed to the app down the websocket, instead of being stored to disk on the gateway.\n"},{"uri":"https://nymtech.net/docs/community/","title":"Community","tags":[],"description":"Some (slowly expanding) notes on the Nym project, its community and governance.","content":"Get involved! Nym is a free software project. We welcome the participation of anyone who values internet privacy and freedom.\nThe Nym platform, and Nym nodes, are infrastructure. The system is designed to provide incentives for people who run the infrastructure, and also for people who write Privacy Enhanced Applications (Peaps). We need people to get involved running reliable infrastructure and building applications.\nRun a Nym node If you have server administration skills and an interest in maintaining high-quality infrastructure, the easiest way to get involved is to download our code and run a node, as detailed in our documentation. As the system progressively gets built, rewards will accrue to node operators who provide the best quality of service, a provable track record, and a good community reputation.\nWrite a Peap Nym allows application developers to build things that previously weren\u0026rsquo;t possible.\nDepending on your skills, you might be interested in building a Service Provider (which performs actions on behalf of users), or a client-facing app (which takes user input and forwards it so Service Providers), or both.\nHelping Nym core If you don\u0026rsquo;t have server admin skills, or the desire to write a Peap, you can still get involved in lots of different ways.\nThe Nym core team is small, and we are thrilled to get help from the wider community.\nTechnical  Rust JavaScript HTML/CSS work other languages (building examples)  Non-technical Tweets, PR help, general advocacy, explanatory help, partnerships, and commercial collaborations are also all very welcome!\n"},{"uri":"https://nymtech.net/docs/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://nymtech.net/docs/","title":"Nym","tags":[],"description":"Nym is a blockchain-based privacy platform. It provides strong network-level privacy against sophisticated end-to-end attackers, and anonymous transactions using blinded, re-randomizable, decentralized credentials.","content":"The Nym Platform Nym is a privacy platform. It provides strong network-level privacy against sophisticated end-to-end attackers, and anonymous access control using blinded, re-randomizable, decentralized credentials.\nOur goal is to allow developers to build new applications, or upgrade existing apps, with privacy features unavailable in other systems.\n"},{"uri":"https://nymtech.net/docs/tags/","title":"Tags","tags":[],"description":"","content":""}]